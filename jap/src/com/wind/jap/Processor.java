package com.wind.jap;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.tools.JavaFileObject;

import com.sun.codemodel.writer.PrologCodeWriter;


@SupportedAnnotationTypes(value= {"*"})
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class Processor extends AbstractProcessor {
	private Filer filer;
	private CodeModel codeModel = new CodeModel();
	private Elements eltUtils;
	
	@Override
	public synchronized void init(ProcessingEnvironment processingEnv) {
		super.init(processingEnv);
		filer = processingEnv.getFiler();
		eltUtils = processingEnv.getElementUtils(); 
		Logger.init(processingEnv);
		Logger.w("INIT ... ");
	}

	@Override
	public Set<String> getSupportedAnnotationTypes() {
		Logger.w("getSupportedAnnotationTypes ... ");
		return ClazzModel.getSupportedAnnotationTypes();
	}

	@Override
	public SourceVersion getSupportedSourceVersion() {
		return SourceVersion.latestSupported();
	}
	public boolean process2(Set<? extends TypeElement> elements, RoundEnvironment env) {

		for (Element element : env.getRootElements()) {

			if (element.getSimpleName().toString().startsWith("Silly")) {
				// We don't want generate new silly classes 
				// for auto-generated silly classes
				continue;
			}

			if (element.getSimpleName().toString().startsWith("T")) {
				Logger.w("process2 ... ");
			}
			Logger.w("process2 --- ... ");
			String sillyClassName = "Silly" + element.getSimpleName();
			String sillyClassContent = 
					"package silly;\n" 
				+	"public class " + sillyClassName + " {\n"
				+	"	public String foobar;\n"
				+	"}";

			JavaFileObject file = null;

			try {
				file = filer.createSourceFile(
						"silly/" + sillyClassName, 
						element);
				file.openWriter()
					.append(sillyClassContent)
					.close();
			} catch (IOException e) {
				e.printStackTrace();
			}

		}

		return true;
	}
	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		
		// TODO Auto-generated method stub
		Logger.w("PROCESS BEGIN: "+annotations.size());
		if( annotations.size() == 0 )
			return true;
		
		for (TypeElement te : annotations) {
			for (Element e : roundEnv.getElementsAnnotatedWith(te)) {
				boolean ret = codeModel.checkIn( eltUtils.getPackageOf(e).getQualifiedName().toString(), getTopLevelClassName(roundEnv, e), te, e);
				if( !ret ){
					Logger.w("PROCESS WARNINGS: "+te.toString()+"  "+e.toString());
				}
			}
		}
		Logger.w("GENRATE BEGIN:  "+annotations.size());
		generateProcessor(filer);
		Logger.w("GENRATE END:  "+annotations.size());
		return true;
	}
	private String getTopLevelClassName(RoundEnvironment roundEnv, Element element) {
		Set<? extends Element> roots =roundEnv.getRootElements();
		while( element != null && !roots.contains(element) ) {
			Logger.w("-----------getTopLevelClassType "+element.getSimpleName()+" -----------"+ element.getEnclosingElement().getSimpleName());
			element = element.getEnclosingElement();
		}
		if( element != null )
			return element.getSimpleName().toString();
		return null;
	}
	private void generateProcessor(Filer filer) {
		
		SourceCodeWriter sourceCodeWriter = new SourceCodeWriter(filer, eltUtils);
		
		PrologCodeWriter prologCodeWriter = new PrologCodeWriter(sourceCodeWriter, "AUTO generated by JAP, DON'T modify.\n");
		try{
			codeModel.generate(prologCodeWriter, sourceCodeWriter);
		}catch (Exception e) {
			StringWriter sw = new StringWriter();
	        PrintWriter pw = new PrintWriter(sw, true);
	        e.printStackTrace(pw);
	        pw.flush();
	        sw.flush();
			Logger.w("				generateProcessor "+sw.toString());
		}
	}   

}