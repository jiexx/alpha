package com.wind.jap;

import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic.Kind;

import com.sun.codemodel.ClassType;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.writer.PrologCodeWriter;
import com.wind.ui.ACTIVITY;
import com.wind.ui.POST;
import com.wind.ui.RECV;
import com.wind.ui.UITHREAD;



public class Processor extends AbstractProcessor {
	private Filer filer;
	private CodeModel codeModel = new CodeModel();
	private Elements eltUtils;
	
	@Override
	public synchronized void init(ProcessingEnvironment processingEnv) {
		super.init(processingEnv);
		filer = processingEnv.getFiler();
		eltUtils = processingEnv.getElementUtils(); 
		Logger.init(processingEnv);
	}

	@Override
	public Set<String> getSupportedAnnotationTypes() {
		return ClazzModel.getSupportedAnnotationTypes();
	}

	@Override
	public SourceVersion getSupportedSourceVersion() {
		return SourceVersion.latestSupported();
	}
	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		// TODO Auto-generated method stub
		for (TypeElement te : annotations) {
			for (Element e : roundEnv.getElementsAnnotatedWith(te)) {
				boolean ret = codeModel.checkIn( getTopLevelClassType(roundEnv, e), te, e);
				if( !ret ){
					Logger.w("PROCESS WARNINGS: "+te.toString()+"  "+e.toString());
				}
			}
		}
		generateProcessor(filer);
		return (true);
	}
	private Class<?> getTopLevelClassType(RoundEnvironment roundEnv, Element element) {
		Set<? extends Element> roots =roundEnv.getRootElements();
		while( element != null && !roots.contains(element) ) 
			element = element.getEnclosingElement();
		if( element != null )
			return element.getClass();
		return null;
	}
	private void generateProcessor(Filer filer) {
		
		SourceCodeWriter sourceCodeWriter = new SourceCodeWriter(filer, eltUtils);
		
		PrologCodeWriter prologCodeWriter = new PrologCodeWriter(sourceCodeWriter, "AUTO generated by JAP, DON'T modify.\n");
		
		codeModel.generate(prologCodeWriter, sourceCodeWriter);
	}   

}